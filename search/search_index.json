{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"neopipe","text":"<p>A Python library for seamless function orchestration, inspired by Rust and scikit-learn pipelines. Designed to streamline workflow management in microservices and AI-powered applications.</p>"},{"location":"#key-features","title":"Key Features:","text":"<ul> <li>Pythonic implementation</li> <li>Efficient function pipelining</li> <li>Inspired by Rust's approach to data flow</li> <li>Tailored for microservices architecture</li> <li>Simplify orchestration of small API driven function (OpenAI, Claudi, other 3rd party API)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install neopipe\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>neopipe</code> was created by MrDataPsycho. It is licensed under the terms of the MIT license.</p>"},{"location":"examples/","title":"Examples","text":"<p>Here are some usage examples for NeoPipe:</p> <pre><code>from typing import Dict, List\nfrom neopipe.pipeline import Pipeline\nfrom neopipe.task import Task\nfrom neopipe.result import Ok, Err, Result\nimport logging\n\n\n# Initialize logging\nlogging.basicConfig(level=logging.INFO)\n# Define your pipeline\npipeline = Pipeline()\n\n\n# Define example tasks using pipeline.task decorator : Method 1 (Using decorator)\n@pipeline.task(retries=3)\ndef get_all_users(data: Dict[str, str]) -&gt; Result[List[str], str]:\n    # Example task: Extract names from data\n    try:\n        names = [item[\"name\"] for item in data]\n        return Ok(names)\n    except KeyError as e:\n        return Err(f\"KeyError: {str(e)}\")\n\n\n# Define example tasks using pipeline\ndef filter_users_by_length(names) -&gt; Result[List[str], str]:\n    # Example task: Filter names based on criteria\n    filtered_names = [name for name in names if len(name) &gt; 3]\n    return Ok(filtered_names)\n\n\ndef calculate_statistics(filtered_names) -&gt; Result[Dict[str, int], str]:\n    # Example task: Calculate statistics\n    statistics = {\n        \"total_names\": len(filtered_names),\n        \"longest_name\": max(filtered_names, key=len) if filtered_names else None,\n    }\n    return Ok(statistics)\n\n\n# Example: Append tasks to the pipeline Alternative Method (Using append_function_as_task)\npipeline.append_function_as_task(filter_users_by_length, retries=2)\n\n# Example: Append tasks to the pipeline Alternative Method (Using append_task)\npipeline.append_task(Task(calculate_statistics, retries=2))\n\n\nif __name__ == \"__main__\":\n    # Sample data\n    sample_data = [\n        {\"name\": \"Alice\"},\n        {\"name\": \"Bob\"},\n        {\"name\": \"Charlie\"},\n        {\"name\": \"David\"},\n        {\"name\": \"Eve\"},\n    ]\n\n    # Run the pipeline\n    result = pipeline.run(\n        sample_data, show_progress=True\n    )  # Set verbosity to True to display progress bar\n\n    # Check the final result\n    if result.is_ok():\n        final_statistics = result.unwrap()\n        logging.info(f\"Pipeline completed successfully. Statistics: {final_statistics}\")\n    else:\n        logging.error(f\"Pipeline failed. Error: {result.unwrap_err()}\")\n</code></pre>"},{"location":"api/pipeline/","title":"Pipeline","text":""},{"location":"api/pipeline/#neopipe.pipeline.Pipeline","title":"<code>Pipeline</code>","text":"Source code in <code>neopipe/pipeline.py</code> <pre><code>class Pipeline:\n    def __init__(self):\n        \"\"\"Create a Pipeline instance.\"\"\"\n        self.tasks: List[Callable[..., Result[Any, Any]]] = []\n\n    @classmethod\n    def from_tasks(cls, tasks: List[Task]) -&gt; Self:\n        \"\"\"\n        Create a Pipeline instance from a list of Task objects.\n        Args:\n            tasks (List[Task]): A list of Task objects.\n        Returns:\n            Pipeline: A new Pipeline instance.\n        \"\"\"\n        pipeline = cls()\n        pipeline.tasks.extend(tasks)\n        return pipeline\n\n    def task(self, retries: int = 1) -&gt; Callable[..., Callable[..., Result[T, E]]]:\n        \"\"\"Create a task decorator.\n\n        Args:\n            retries (int, optional): The number of times to retry the task. Defaults to 1.\n\n        Returns:\n            Callable[..., Callable[..., Result[T, E]]]: A task decorator.\n        \"\"\"\n        def decorator(func: Callable[..., Result[T, E]]) -&gt; Callable[..., Result[T, E]]:\n            task_instance = Task(func, retries=retries)\n            self.tasks.append(task_instance)\n\n            @wraps(func)\n            def wrapped_func(*args, **kwargs) -&gt; Result[T, E]:\n                return task_instance(*args, **kwargs)\n\n            return wrapped_func\n\n        return decorator\n\n    def append_function_as_task(\n        self, func: Callable[..., Result[T, E]], retries: int = 1\n    ) -&gt; None:\n        \"\"\"Append a task to the pipeline.\n\n        Args:\n            func (Callable[..., Result[T, E]]): The function to be appended as a task.\n            retries (int, optional): The number of times to retry the task. Defaults to 1.\n        Returns:\n            None\n        \"\"\"\n        task_instance = Task(func, retries=retries)\n        self.tasks.append(task_instance)\n\n    def run(self, initial_value: Any, show_progress: bool = False) -&gt; Result:\n        result = Ok(initial_value)\n        task_iter = (\n            self.tasks\n            if not show_progress\n            else tqdm(\n                self.tasks,\n                desc=\"Pipeline Progress\",\n                bar_format=\"{l_bar}{bar} [ {elapsed} ]\",\n            )\n        )\n\n        for task in task_iter:\n            if result.is_ok():\n                result = task(result.value)\n                if result.is_err():\n                    logging.error(f\"Pipeline stopped due to error: {result.error}\")\n                    return result\n        return result\n\n    def append_task(self, task: Task) -&gt; None:\n        \"\"\"Append a Task object to the pipeline.\n        Args:\n            task (Task): The task to be appended.\n        Returns:\n            None\n        \"\"\"\n        if not isinstance(task, Task):\n            raise ValueError(\n                \"task must be an instance of Task not a {}\".format(type(task))\n            )\n        self.tasks.append(task)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the pipeline.\"\"\"\n        tasks_str = \"\\n  \".join(str(task) for task in self.tasks)\n        return f\"Pipeline with {len(self.tasks)} tasks:\\n  {tasks_str}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the pipeline.\"\"\"\n        return self.__str__()\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.__init__","title":"<code>__init__()</code>","text":"<p>Create a Pipeline instance.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def __init__(self):\n    \"\"\"Create a Pipeline instance.\"\"\"\n    self.tasks: List[Callable[..., Result[Any, Any]]] = []\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the pipeline.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the pipeline.\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the pipeline.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the pipeline.\"\"\"\n    tasks_str = \"\\n  \".join(str(task) for task in self.tasks)\n    return f\"Pipeline with {len(self.tasks)} tasks:\\n  {tasks_str}\"\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.append_function_as_task","title":"<code>append_function_as_task(func, retries=1)</code>","text":"<p>Append a task to the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Result[T, E]]</code> <p>The function to be appended as a task.</p> required <code>retries</code> <code>int</code> <p>The number of times to retry the task. Defaults to 1.</p> <code>1</code> <p>Returns:     None</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def append_function_as_task(\n    self, func: Callable[..., Result[T, E]], retries: int = 1\n) -&gt; None:\n    \"\"\"Append a task to the pipeline.\n\n    Args:\n        func (Callable[..., Result[T, E]]): The function to be appended as a task.\n        retries (int, optional): The number of times to retry the task. Defaults to 1.\n    Returns:\n        None\n    \"\"\"\n    task_instance = Task(func, retries=retries)\n    self.tasks.append(task_instance)\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.append_task","title":"<code>append_task(task)</code>","text":"<p>Append a Task object to the pipeline. Args:     task (Task): The task to be appended. Returns:     None</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def append_task(self, task: Task) -&gt; None:\n    \"\"\"Append a Task object to the pipeline.\n    Args:\n        task (Task): The task to be appended.\n    Returns:\n        None\n    \"\"\"\n    if not isinstance(task, Task):\n        raise ValueError(\n            \"task must be an instance of Task not a {}\".format(type(task))\n        )\n    self.tasks.append(task)\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.from_tasks","title":"<code>from_tasks(tasks)</code>  <code>classmethod</code>","text":"<p>Create a Pipeline instance from a list of Task objects. Args:     tasks (List[Task]): A list of Task objects. Returns:     Pipeline: A new Pipeline instance.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>@classmethod\ndef from_tasks(cls, tasks: List[Task]) -&gt; Self:\n    \"\"\"\n    Create a Pipeline instance from a list of Task objects.\n    Args:\n        tasks (List[Task]): A list of Task objects.\n    Returns:\n        Pipeline: A new Pipeline instance.\n    \"\"\"\n    pipeline = cls()\n    pipeline.tasks.extend(tasks)\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.task","title":"<code>task(retries=1)</code>","text":"<p>Create a task decorator.</p> <p>Parameters:</p> Name Type Description Default <code>retries</code> <code>int</code> <p>The number of times to retry the task. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Callable[..., Callable[..., Result[T, E]]]</code> <p>Callable[..., Callable[..., Result[T, E]]]: A task decorator.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def task(self, retries: int = 1) -&gt; Callable[..., Callable[..., Result[T, E]]]:\n    \"\"\"Create a task decorator.\n\n    Args:\n        retries (int, optional): The number of times to retry the task. Defaults to 1.\n\n    Returns:\n        Callable[..., Callable[..., Result[T, E]]]: A task decorator.\n    \"\"\"\n    def decorator(func: Callable[..., Result[T, E]]) -&gt; Callable[..., Result[T, E]]:\n        task_instance = Task(func, retries=retries)\n        self.tasks.append(task_instance)\n\n        @wraps(func)\n        def wrapped_func(*args, **kwargs) -&gt; Result[T, E]:\n            return task_instance(*args, **kwargs)\n\n        return wrapped_func\n\n    return decorator\n</code></pre>"},{"location":"api/result/","title":"Result","text":""},{"location":"api/result/#neopipe.result.Result","title":"<code>Result</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T, E]</code></p> <p>Result type for the neopipe package.</p> Source code in <code>neopipe/result.py</code> <pre><code>@dataclass\nclass Result(Generic[T, E]):\n    \"\"\"Result type for the neopipe package.\"\"\"\n    value: Optional[T] = field(default=None)\n    error: Optional[E] = field(default=None)\n\n    def is_ok(self) -&gt; bool:\n        \"\"\"Checks if the Result is an Ok value.\n\n        Returns:\n            bool: True if the Result is an Ok value, False otherwise\n        \"\"\"\n        return self.error is None\n\n    def is_err(self) -&gt; bool:\n        \"\"\"Checks if the Result is an Err value.\"\"\"\n        return self.error is not None\n\n    def unwrap(self) -&gt; T:\n        \"\"\"Unwraps the Result value if it is an Ok value, otherwise raises a ValueError.\n\n        Raises:\n            ValueError: If the Result is an Err value\n\n        Returns:\n            T: The unwrapped value\n        \"\"\"\n        if self.is_err():\n            raise ValueError(f\"Called unwrap on an Err value: {self.error}\")\n        return self.value\n\n    def unwrap_err(self) -&gt; E:\n        \"\"\"Unwraps the Result error if it is an Err value, otherwise raises a ValueError.\n\n        Raises:\n            ValueError: If the Result is an Ok value\n\n        Returns:\n            E: The unwrapped error\n        \"\"\"\n        if self.is_ok():\n            raise ValueError(f\"Called unwrap_err on an Ok value: {self.value}\")\n        return self.error\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Converts the Result to a dictionary.\n\n        Returns:\n            dict: The Result as a dictionary\n        \"\"\"\n        return asdict(self)\n\n    def to_json(self) -&gt; str:\n        \"\"\"Converts the Result to a JSON string.\n\n        Returns:\n            str: The Result as a JSON string\n        \"\"\"\n        return json.dumps(self.to_dict())\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.is_err","title":"<code>is_err()</code>","text":"<p>Checks if the Result is an Err value.</p> Source code in <code>neopipe/result.py</code> <pre><code>def is_err(self) -&gt; bool:\n    \"\"\"Checks if the Result is an Err value.\"\"\"\n    return self.error is not None\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.is_ok","title":"<code>is_ok()</code>","text":"<p>Checks if the Result is an Ok value.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Result is an Ok value, False otherwise</p> Source code in <code>neopipe/result.py</code> <pre><code>def is_ok(self) -&gt; bool:\n    \"\"\"Checks if the Result is an Ok value.\n\n    Returns:\n        bool: True if the Result is an Ok value, False otherwise\n    \"\"\"\n    return self.error is None\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the Result to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The Result as a dictionary</p> Source code in <code>neopipe/result.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Converts the Result to a dictionary.\n\n    Returns:\n        dict: The Result as a dictionary\n    \"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.to_json","title":"<code>to_json()</code>","text":"<p>Converts the Result to a JSON string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Result as a JSON string</p> Source code in <code>neopipe/result.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Converts the Result to a JSON string.\n\n    Returns:\n        str: The Result as a JSON string\n    \"\"\"\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.unwrap","title":"<code>unwrap()</code>","text":"<p>Unwraps the Result value if it is an Ok value, otherwise raises a ValueError.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Result is an Err value</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The unwrapped value</p> Source code in <code>neopipe/result.py</code> <pre><code>def unwrap(self) -&gt; T:\n    \"\"\"Unwraps the Result value if it is an Ok value, otherwise raises a ValueError.\n\n    Raises:\n        ValueError: If the Result is an Err value\n\n    Returns:\n        T: The unwrapped value\n    \"\"\"\n    if self.is_err():\n        raise ValueError(f\"Called unwrap on an Err value: {self.error}\")\n    return self.value\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.unwrap_err","title":"<code>unwrap_err()</code>","text":"<p>Unwraps the Result error if it is an Err value, otherwise raises a ValueError.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Result is an Ok value</p> <p>Returns:</p> Name Type Description <code>E</code> <code>E</code> <p>The unwrapped error</p> Source code in <code>neopipe/result.py</code> <pre><code>def unwrap_err(self) -&gt; E:\n    \"\"\"Unwraps the Result error if it is an Err value, otherwise raises a ValueError.\n\n    Raises:\n        ValueError: If the Result is an Ok value\n\n    Returns:\n        E: The unwrapped error\n    \"\"\"\n    if self.is_ok():\n        raise ValueError(f\"Called unwrap_err on an Ok value: {self.value}\")\n    return self.error\n</code></pre>"},{"location":"api/result/#neopipe.result.Err","title":"<code>Err(error)</code>","text":"<p>Creates an Err Result with the given error.</p> Source code in <code>neopipe/result.py</code> <pre><code>def Err(error: E) -&gt; Result[None, E]:\n    \"\"\"Creates an Err Result with the given error.\"\"\"\n    return Result(error=error)\n</code></pre>"},{"location":"api/result/#neopipe.result.Ok","title":"<code>Ok(value)</code>","text":"<p>Creates an Ok Result with the given value.</p> Source code in <code>neopipe/result.py</code> <pre><code>def Ok(value: T) -&gt; Result[T, None]:\n    \"\"\"Creates an Ok Result with the given value.\"\"\"\n    return Result(value=value)\n</code></pre>"},{"location":"api/task/","title":"Task","text":""},{"location":"api/task/#neopipe.task.Task","title":"<code>Task</code>","text":"<p>Task is a wrapper around a function that can be retried.</p> Source code in <code>neopipe/task.py</code> <pre><code>class Task:\n    \"\"\"Task is a wrapper around a function that can be retried.\"\"\"\n    def __init__(self, func: Callable[..., Result[T, E]], retries: int = 1):\n        \"\"\"\n        Task is a wrapper around a function that can be retried.\n\n        Args:\n            func (Callable[..., Result[T, E]]): _description_\n            retries (int, optional): _description_. Defaults to 1.\n        \"\"\"\n        self.func = func\n        self.retries = retries\n        self.id = uuid.uuid4()\n\n    def __call__(self, *args, **kwargs) -&gt; Result[T, E]:\n        \"\"\"\n        Execute the task and retry if it fails.\n\n        Returns:\n            Result[T, E]: The result of the task\n        \"\"\"\n        @wraps(self.func)\n        def wrapped_func(*args, **kwargs) -&gt; Result[T, E]:\n            logging.info(f\"Executing task {self.func.__name__} (UUID: {self.id})\")\n            last_exception = None\n            for attempt in range(self.retries):\n                try:\n                    result = self.func(*args, **kwargs)\n                    if result.is_ok():\n                        logging.info(\n                            f\"Task {self.func.__name__} succeeded on attempt {attempt + 1}\"\n                        )\n                        return result\n                    else:\n                        logging.error(\n                            f\"Task {self.func.__name__} failed on attempt {attempt + 1}: {result.error}\"\n                        )\n                        return result\n                except Exception as e:\n                    last_exception = e\n                    logging.error(\n                        f\"Task {self.func.__name__} exception on attempt {attempt + 1}: {str(e)}\"\n                    )\n                    time.sleep(2**attempt)  # Exponential backoff\n\n            return Err(\n                f\"Task {self.func.__name__} failed after {self.retries} attempts: {str(last_exception)}\"\n            )\n\n        return wrapped_func(*args, **kwargs)\n\n    def __str__(self):\n        \"\"\"Return a string representation of the task.\"\"\"\n        return f\"Task({self.func.__name__}, retries={self.retries})\"\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the task.\"\"\"\n        return self.__str__()\n</code></pre>"},{"location":"api/task/#neopipe.task.Task.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Execute the task and retry if it fails.</p> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The result of the task</p> Source code in <code>neopipe/task.py</code> <pre><code>def __call__(self, *args, **kwargs) -&gt; Result[T, E]:\n    \"\"\"\n    Execute the task and retry if it fails.\n\n    Returns:\n        Result[T, E]: The result of the task\n    \"\"\"\n    @wraps(self.func)\n    def wrapped_func(*args, **kwargs) -&gt; Result[T, E]:\n        logging.info(f\"Executing task {self.func.__name__} (UUID: {self.id})\")\n        last_exception = None\n        for attempt in range(self.retries):\n            try:\n                result = self.func(*args, **kwargs)\n                if result.is_ok():\n                    logging.info(\n                        f\"Task {self.func.__name__} succeeded on attempt {attempt + 1}\"\n                    )\n                    return result\n                else:\n                    logging.error(\n                        f\"Task {self.func.__name__} failed on attempt {attempt + 1}: {result.error}\"\n                    )\n                    return result\n            except Exception as e:\n                last_exception = e\n                logging.error(\n                    f\"Task {self.func.__name__} exception on attempt {attempt + 1}: {str(e)}\"\n                )\n                time.sleep(2**attempt)  # Exponential backoff\n\n        return Err(\n            f\"Task {self.func.__name__} failed after {self.retries} attempts: {str(last_exception)}\"\n        )\n\n    return wrapped_func(*args, **kwargs)\n</code></pre>"},{"location":"api/task/#neopipe.task.Task.__init__","title":"<code>__init__(func, retries=1)</code>","text":"<p>Task is a wrapper around a function that can be retried.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Result[T, E]]</code> <p>description</p> required <code>retries</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> Source code in <code>neopipe/task.py</code> <pre><code>def __init__(self, func: Callable[..., Result[T, E]], retries: int = 1):\n    \"\"\"\n    Task is a wrapper around a function that can be retried.\n\n    Args:\n        func (Callable[..., Result[T, E]]): _description_\n        retries (int, optional): _description_. Defaults to 1.\n    \"\"\"\n    self.func = func\n    self.retries = retries\n    self.id = uuid.uuid4()\n</code></pre>"},{"location":"api/task/#neopipe.task.Task.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the task.</p> Source code in <code>neopipe/task.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return a string representation of the task.\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"api/task/#neopipe.task.Task.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the task.</p> Source code in <code>neopipe/task.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of the task.\"\"\"\n    return f\"Task({self.func.__name__}, retries={self.retries})\"\n</code></pre>"}]}