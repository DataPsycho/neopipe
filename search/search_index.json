{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#neopipe","title":"NeoPipe","text":"<p>A Python library for seamless function orchestration, inspired by Rust and scikit-learn pipelines. Designed to streamline workflow management in microservices and AI-powered applications.</p>"},{"location":"#key-features","title":"Key Features:","text":"<ul> <li>Pythonic implementation</li> <li>Efficient function pipelining</li> <li>Inspired by Rust's approach to data flow</li> <li>Tailored for microservices architecture</li> <li>Simplify orchestration of small API driven function (OpenAI, Claudi, other 3rd party API)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install neopipe\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>neopipe</code> was created by MrDataPsycho. It is licensed under the terms of the MIT license.</p>"},{"location":"api/pipeline/","title":"Pipeline","text":""},{"location":"api/pipeline/#neopipe.pipeline.Pipeline","title":"<code>Pipeline</code>","text":"Source code in <code>neopipe/pipeline.py</code> <pre><code>class Pipeline:\n    def __init__(self):\n        \"\"\"Create a Pipeline instance.\"\"\"\n        self.registry: List[Callable[..., Result[Any, Any]]] = []\n\n    @classmethod\n    def from_tasks(cls, tasks: List[Task]) -&gt; Self:\n        \"\"\"\n        Create a Pipeline instance from a list of Task objects.\n\n        Args:\n            tasks (List[Task]): A list of Task objects.\n\n        Returns:\n            Pipeline: A new Pipeline instance.\n        \"\"\"\n        pipeline = cls()\n        pipeline.registry.extend(tasks)\n        return pipeline\n\n    def register(self, retries: int = 1) -&gt; Callable[..., Callable[..., Result[T, E]]]:\n        \"\"\"\n        Create a task decorator to register a function as a task.\n\n        Args:\n            retries (int, optional): The number of times to retry the task. Defaults to 1.\n\n        Returns:\n            Callable[..., Callable[..., Result[T, E]]]: A task decorator.\n        \"\"\"\n        def decorator(func: Callable[..., Result[T, E]]) -&gt; Callable[..., Result[T, E]]:\n            task_instance = Task(func, retries=retries)\n            self.registry.append(task_instance)\n\n            @wraps(func)\n            def wrapped_func(*args, **kwargs) -&gt; Result[T, E]:\n                return task_instance(*args, **kwargs)\n\n            return wrapped_func\n\n        return decorator\n\n    def append_function_to_registry(\n        self, func: Callable[..., Result[T, E]], retries: int = 1\n    ) -&gt; None:\n        \"\"\"\n        Append a function as a task to the registry.\n\n        Args:\n            func (Callable[..., Result[T, E]]): The function to be appended as a task.\n            retries (int, optional): The number of times to retry the task. Defaults to 1.\n\n        Returns:\n            None\n        \"\"\"\n        task_instance = Task(func, retries=retries)\n        self.registry.append(task_instance)\n\n    def append_task_to_registry(self, task: Task) -&gt; None:\n        \"\"\"\n        Append a Task object to the registry.\n\n        Args:\n            task (Task): The task to be appended.\n\n        Returns:\n            None\n        \"\"\"\n        if not isinstance(task, Task):\n            raise ValueError(\n                \"task must be an instance of Task not a {}\".format(type(task))\n            )\n        self.registry.append(task)\n\n    def run(self, initial_value: Any, show_progress: bool = False) -&gt; Result:\n        \"\"\"\n        Execute the pipeline with the initial value.\n\n        Args:\n            initial_value (Any): The initial value to start the pipeline with.\n            show_progress (bool, optional): Whether to show a progress bar. Defaults to False.\n\n        Returns:\n            Result: The result of the pipeline execution.\n        \"\"\"\n        result = Ok(initial_value)\n        task_iter = (\n            self.registry\n            if not show_progress\n            else tqdm(\n                self.registry,\n                desc=\"Pipeline Progress\",\n                bar_format=\"{l_bar}{bar} [ {elapsed} ]\",\n            )\n        )\n\n        for task in task_iter:\n            if result.is_ok():\n                result = task(result.value)\n                if result.is_err():\n                    logger.error(f\"Pipeline stopped due to error: {result.error}\")\n                    return result\n        return result\n\n    def print_execution_plan(self) -&gt; None:\n        \"\"\"\n        Print the execution plan of the pipeline, showing the sequence of tasks and \n        the expected input/output data types.\n        \"\"\"\n        if not self.registry:\n            print(\"Pipeline is empty.\")\n            return\n\n        print(\"Pipeline Execution Plan:\")\n        print(\"=\"*30)\n        for i, task in enumerate(self.registry):\n            func_name = task.func.__name__\n            input_type = task.func.__annotations__.get('return', 'Any')\n            output_type = list(task.func.__annotations__.values())[0] if task.func.__annotations__ else 'Any'\n\n            print(f\"{func_name} : {output_type} -&gt; {input_type}\")\n\n            if i &lt; len(self.registry) - 1:\n                print(\" |\")\n                print(\" |\")\n                print(\" V\")\n        print(\"=\"*30)\n\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the pipeline.\"\"\"\n        tasks_str = \"\\n  \".join(str(task) for task in self.registry)\n        return f\"Pipeline with {len(self.registry)} tasks:\\n  {tasks_str}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the pipeline.\"\"\"\n        return self.__str__()\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.__init__","title":"<code>__init__()</code>","text":"<p>Create a Pipeline instance.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def __init__(self):\n    \"\"\"Create a Pipeline instance.\"\"\"\n    self.registry: List[Callable[..., Result[Any, Any]]] = []\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the pipeline.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the pipeline.\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the pipeline.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the pipeline.\"\"\"\n    tasks_str = \"\\n  \".join(str(task) for task in self.registry)\n    return f\"Pipeline with {len(self.registry)} tasks:\\n  {tasks_str}\"\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.append_function_to_registry","title":"<code>append_function_to_registry(func, retries=1)</code>","text":"<p>Append a function as a task to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Result[T, E]]</code> <p>The function to be appended as a task.</p> required <code>retries</code> <code>int</code> <p>The number of times to retry the task. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def append_function_to_registry(\n    self, func: Callable[..., Result[T, E]], retries: int = 1\n) -&gt; None:\n    \"\"\"\n    Append a function as a task to the registry.\n\n    Args:\n        func (Callable[..., Result[T, E]]): The function to be appended as a task.\n        retries (int, optional): The number of times to retry the task. Defaults to 1.\n\n    Returns:\n        None\n    \"\"\"\n    task_instance = Task(func, retries=retries)\n    self.registry.append(task_instance)\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.append_task_to_registry","title":"<code>append_task_to_registry(task)</code>","text":"<p>Append a Task object to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>The task to be appended.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def append_task_to_registry(self, task: Task) -&gt; None:\n    \"\"\"\n    Append a Task object to the registry.\n\n    Args:\n        task (Task): The task to be appended.\n\n    Returns:\n        None\n    \"\"\"\n    if not isinstance(task, Task):\n        raise ValueError(\n            \"task must be an instance of Task not a {}\".format(type(task))\n        )\n    self.registry.append(task)\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.from_tasks","title":"<code>from_tasks(tasks)</code>  <code>classmethod</code>","text":"<p>Create a Pipeline instance from a list of Task objects.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>List[Task]</code> <p>A list of Task objects.</p> required <p>Returns:</p> Name Type Description <code>Pipeline</code> <code>Self</code> <p>A new Pipeline instance.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>@classmethod\ndef from_tasks(cls, tasks: List[Task]) -&gt; Self:\n    \"\"\"\n    Create a Pipeline instance from a list of Task objects.\n\n    Args:\n        tasks (List[Task]): A list of Task objects.\n\n    Returns:\n        Pipeline: A new Pipeline instance.\n    \"\"\"\n    pipeline = cls()\n    pipeline.registry.extend(tasks)\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.print_execution_plan","title":"<code>print_execution_plan()</code>","text":"<p>Print the execution plan of the pipeline, showing the sequence of tasks and  the expected input/output data types.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def print_execution_plan(self) -&gt; None:\n    \"\"\"\n    Print the execution plan of the pipeline, showing the sequence of tasks and \n    the expected input/output data types.\n    \"\"\"\n    if not self.registry:\n        print(\"Pipeline is empty.\")\n        return\n\n    print(\"Pipeline Execution Plan:\")\n    print(\"=\"*30)\n    for i, task in enumerate(self.registry):\n        func_name = task.func.__name__\n        input_type = task.func.__annotations__.get('return', 'Any')\n        output_type = list(task.func.__annotations__.values())[0] if task.func.__annotations__ else 'Any'\n\n        print(f\"{func_name} : {output_type} -&gt; {input_type}\")\n\n        if i &lt; len(self.registry) - 1:\n            print(\" |\")\n            print(\" |\")\n            print(\" V\")\n    print(\"=\"*30)\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.register","title":"<code>register(retries=1)</code>","text":"<p>Create a task decorator to register a function as a task.</p> <p>Parameters:</p> Name Type Description Default <code>retries</code> <code>int</code> <p>The number of times to retry the task. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Callable[..., Callable[..., Result[T, E]]]</code> <p>Callable[..., Callable[..., Result[T, E]]]: A task decorator.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def register(self, retries: int = 1) -&gt; Callable[..., Callable[..., Result[T, E]]]:\n    \"\"\"\n    Create a task decorator to register a function as a task.\n\n    Args:\n        retries (int, optional): The number of times to retry the task. Defaults to 1.\n\n    Returns:\n        Callable[..., Callable[..., Result[T, E]]]: A task decorator.\n    \"\"\"\n    def decorator(func: Callable[..., Result[T, E]]) -&gt; Callable[..., Result[T, E]]:\n        task_instance = Task(func, retries=retries)\n        self.registry.append(task_instance)\n\n        @wraps(func)\n        def wrapped_func(*args, **kwargs) -&gt; Result[T, E]:\n            return task_instance(*args, **kwargs)\n\n        return wrapped_func\n\n    return decorator\n</code></pre>"},{"location":"api/pipeline/#neopipe.pipeline.Pipeline.run","title":"<code>run(initial_value, show_progress=False)</code>","text":"<p>Execute the pipeline with the initial value.</p> <p>Parameters:</p> Name Type Description Default <code>initial_value</code> <code>Any</code> <p>The initial value to start the pipeline with.</p> required <code>show_progress</code> <code>bool</code> <p>Whether to show a progress bar. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>The result of the pipeline execution.</p> Source code in <code>neopipe/pipeline.py</code> <pre><code>def run(self, initial_value: Any, show_progress: bool = False) -&gt; Result:\n    \"\"\"\n    Execute the pipeline with the initial value.\n\n    Args:\n        initial_value (Any): The initial value to start the pipeline with.\n        show_progress (bool, optional): Whether to show a progress bar. Defaults to False.\n\n    Returns:\n        Result: The result of the pipeline execution.\n    \"\"\"\n    result = Ok(initial_value)\n    task_iter = (\n        self.registry\n        if not show_progress\n        else tqdm(\n            self.registry,\n            desc=\"Pipeline Progress\",\n            bar_format=\"{l_bar}{bar} [ {elapsed} ]\",\n        )\n    )\n\n    for task in task_iter:\n        if result.is_ok():\n            result = task(result.value)\n            if result.is_err():\n                logger.error(f\"Pipeline stopped due to error: {result.error}\")\n                return result\n    return result\n</code></pre>"},{"location":"api/result/","title":"Result","text":""},{"location":"api/result/#neopipe.result.Result","title":"<code>Result</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T, E]</code></p> <p>Result type for the neopipe package.</p> Source code in <code>neopipe/result.py</code> <pre><code>@dataclass\nclass Result(Generic[T, E]):\n    \"\"\"Result type for the neopipe package.\"\"\"\n    value: Optional[T] = field(default=None)\n    error: Optional[E] = field(default=None)\n\n    def is_ok(self) -&gt; bool:\n        \"\"\"Checks if the Result is an Ok value.\n\n        Returns:\n            bool: True if the Result is an Ok value, False otherwise\n        \"\"\"\n        return self.error is None\n\n    def is_err(self) -&gt; bool:\n        \"\"\"Checks if the Result is an Err value.\"\"\"\n        return self.error is not None\n\n    def unwrap(self) -&gt; T:\n        \"\"\"Unwraps the Result value if it is an Ok value, otherwise raises a ValueError.\n\n        Raises:\n            ValueError: If the Result is an Err value\n\n        Returns:\n            T: The unwrapped value\n        \"\"\"\n        if self.is_err():\n            raise ValueError(f\"Called unwrap on an Err value: {self.error}\")\n        return self.value\n\n    def unwrap_err(self) -&gt; E:\n        \"\"\"Unwraps the Result error if it is an Err value, otherwise raises a ValueError.\n\n        Raises:\n            ValueError: If the Result is an Ok value\n\n        Returns:\n            E: The unwrapped error\n        \"\"\"\n        if self.is_ok():\n            raise ValueError(f\"Called unwrap_err on an Ok value: {self.value}\")\n        return self.error\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Converts the Result to a dictionary.\n\n        Returns:\n            dict: The Result as a dictionary\n        \"\"\"\n        return asdict(self)\n\n    def to_json(self) -&gt; str:\n        \"\"\"Converts the Result to a JSON string.\n\n        Returns:\n            str: The Result as a JSON string\n        \"\"\"\n        return json.dumps(self.to_dict())\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.is_err","title":"<code>is_err()</code>","text":"<p>Checks if the Result is an Err value.</p> Source code in <code>neopipe/result.py</code> <pre><code>def is_err(self) -&gt; bool:\n    \"\"\"Checks if the Result is an Err value.\"\"\"\n    return self.error is not None\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.is_ok","title":"<code>is_ok()</code>","text":"<p>Checks if the Result is an Ok value.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Result is an Ok value, False otherwise</p> Source code in <code>neopipe/result.py</code> <pre><code>def is_ok(self) -&gt; bool:\n    \"\"\"Checks if the Result is an Ok value.\n\n    Returns:\n        bool: True if the Result is an Ok value, False otherwise\n    \"\"\"\n    return self.error is None\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the Result to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The Result as a dictionary</p> Source code in <code>neopipe/result.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Converts the Result to a dictionary.\n\n    Returns:\n        dict: The Result as a dictionary\n    \"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.to_json","title":"<code>to_json()</code>","text":"<p>Converts the Result to a JSON string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Result as a JSON string</p> Source code in <code>neopipe/result.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Converts the Result to a JSON string.\n\n    Returns:\n        str: The Result as a JSON string\n    \"\"\"\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.unwrap","title":"<code>unwrap()</code>","text":"<p>Unwraps the Result value if it is an Ok value, otherwise raises a ValueError.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Result is an Err value</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The unwrapped value</p> Source code in <code>neopipe/result.py</code> <pre><code>def unwrap(self) -&gt; T:\n    \"\"\"Unwraps the Result value if it is an Ok value, otherwise raises a ValueError.\n\n    Raises:\n        ValueError: If the Result is an Err value\n\n    Returns:\n        T: The unwrapped value\n    \"\"\"\n    if self.is_err():\n        raise ValueError(f\"Called unwrap on an Err value: {self.error}\")\n    return self.value\n</code></pre>"},{"location":"api/result/#neopipe.result.Result.unwrap_err","title":"<code>unwrap_err()</code>","text":"<p>Unwraps the Result error if it is an Err value, otherwise raises a ValueError.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Result is an Ok value</p> <p>Returns:</p> Name Type Description <code>E</code> <code>E</code> <p>The unwrapped error</p> Source code in <code>neopipe/result.py</code> <pre><code>def unwrap_err(self) -&gt; E:\n    \"\"\"Unwraps the Result error if it is an Err value, otherwise raises a ValueError.\n\n    Raises:\n        ValueError: If the Result is an Ok value\n\n    Returns:\n        E: The unwrapped error\n    \"\"\"\n    if self.is_ok():\n        raise ValueError(f\"Called unwrap_err on an Ok value: {self.value}\")\n    return self.error\n</code></pre>"},{"location":"api/result/#neopipe.result.Err","title":"<code>Err(error)</code>","text":"<p>Creates an Err Result with the given error.</p> Source code in <code>neopipe/result.py</code> <pre><code>def Err(error: E) -&gt; Result[None, E]:\n    \"\"\"Creates an Err Result with the given error.\"\"\"\n    return Result(error=error)\n</code></pre>"},{"location":"api/result/#neopipe.result.Ok","title":"<code>Ok(value)</code>","text":"<p>Creates an Ok Result with the given value.</p> Source code in <code>neopipe/result.py</code> <pre><code>def Ok(value: T) -&gt; Result[T, None]:\n    \"\"\"Creates an Ok Result with the given value.\"\"\"\n    return Result(value=value)\n</code></pre>"},{"location":"api/task/","title":"Task","text":""},{"location":"api/task/#neopipe.task.Task","title":"<code>Task</code>","text":"<p>Task is a wrapper around a function that can be retried.</p> Source code in <code>neopipe/task.py</code> <pre><code>class Task:\n    \"\"\"Task is a wrapper around a function that can be retried.\"\"\"\n    def __init__(self, func: Callable[..., Result[T, E]], retries: int = 1):\n        \"\"\"\n        Task is a wrapper around a function that can be retried.\n\n        Args:\n            func (Callable[..., Result[T, E]]): _description_\n            retries (int, optional): _description_. Defaults to 1.\n        \"\"\"\n        self.func = func\n        self.retries = retries\n        self.id = uuid.uuid4()\n\n    def __call__(self, *args, **kwargs) -&gt; Result[T, E]:\n        \"\"\"\n        Execute the task and retry if it fails.\n\n        Returns:\n            Result[T, E]: The result of the task\n        \"\"\"\n        @wraps(self.func)\n        def wrapped_func(*args, **kwargs) -&gt; Result[T, E]:\n            logger.info(f\"Executing task {self.func.__name__} (UUID: {self.id})\")\n            last_exception = None\n            for attempt in range(self.retries):\n                try:\n                    result = self.func(*args, **kwargs)\n                    if result.is_ok():\n                        logger.info(\n                            f\"Task {self.func.__name__} succeeded on attempt {attempt + 1}\"\n                        )\n                        return result\n                    else:\n                        logger.error(\n                            f\"Task {self.func.__name__} failed on attempt {attempt + 1}: {result.error}\"\n                        )\n                        return result\n                except Exception as e:\n                    last_exception = e\n                    logger.error(\n                        f\"Task {self.func.__name__} exception on attempt {attempt + 1}: {str(e)}\"\n                    )\n                    time.sleep(2**attempt)  # Exponential backoff\n\n            return Err(\n                f\"Task {self.func.__name__} failed after {self.retries} attempts: {str(last_exception)}\"\n            )\n\n        return wrapped_func(*args, **kwargs)\n\n    def __str__(self):\n        \"\"\"Return a string representation of the task.\"\"\"\n        return f\"Task({self.func.__name__}, retries={self.retries})\"\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the task.\"\"\"\n        return self.__str__()\n</code></pre>"},{"location":"api/task/#neopipe.task.Task.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Execute the task and retry if it fails.</p> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The result of the task</p> Source code in <code>neopipe/task.py</code> <pre><code>def __call__(self, *args, **kwargs) -&gt; Result[T, E]:\n    \"\"\"\n    Execute the task and retry if it fails.\n\n    Returns:\n        Result[T, E]: The result of the task\n    \"\"\"\n    @wraps(self.func)\n    def wrapped_func(*args, **kwargs) -&gt; Result[T, E]:\n        logger.info(f\"Executing task {self.func.__name__} (UUID: {self.id})\")\n        last_exception = None\n        for attempt in range(self.retries):\n            try:\n                result = self.func(*args, **kwargs)\n                if result.is_ok():\n                    logger.info(\n                        f\"Task {self.func.__name__} succeeded on attempt {attempt + 1}\"\n                    )\n                    return result\n                else:\n                    logger.error(\n                        f\"Task {self.func.__name__} failed on attempt {attempt + 1}: {result.error}\"\n                    )\n                    return result\n            except Exception as e:\n                last_exception = e\n                logger.error(\n                    f\"Task {self.func.__name__} exception on attempt {attempt + 1}: {str(e)}\"\n                )\n                time.sleep(2**attempt)  # Exponential backoff\n\n        return Err(\n            f\"Task {self.func.__name__} failed after {self.retries} attempts: {str(last_exception)}\"\n        )\n\n    return wrapped_func(*args, **kwargs)\n</code></pre>"},{"location":"api/task/#neopipe.task.Task.__init__","title":"<code>__init__(func, retries=1)</code>","text":"<p>Task is a wrapper around a function that can be retried.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Result[T, E]]</code> <p>description</p> required <code>retries</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> Source code in <code>neopipe/task.py</code> <pre><code>def __init__(self, func: Callable[..., Result[T, E]], retries: int = 1):\n    \"\"\"\n    Task is a wrapper around a function that can be retried.\n\n    Args:\n        func (Callable[..., Result[T, E]]): _description_\n        retries (int, optional): _description_. Defaults to 1.\n    \"\"\"\n    self.func = func\n    self.retries = retries\n    self.id = uuid.uuid4()\n</code></pre>"},{"location":"api/task/#neopipe.task.Task.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the task.</p> Source code in <code>neopipe/task.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return a string representation of the task.\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"api/task/#neopipe.task.Task.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the task.</p> Source code in <code>neopipe/task.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of the task.\"\"\"\n    return f\"Task({self.func.__name__}, retries={self.retries})\"\n</code></pre>"},{"location":"examples/basic_use/","title":"Neopipe Example:","text":"<p>Here are some basic usage examples for NeoPipe:</p> <pre><code>from typing import Dict, List\nfrom neopipe.pipeline import Pipeline\nfrom neopipe.task import Task\nfrom neopipe.result import Ok, Err, Result\nimport logging\n\n\n# Initialize logging\nlogging.basicConfig(level=logging.INFO)\n# Define your pipeline\npipeline = Pipeline()\n\n\n# Define example tasks using pipeline.task decorator : Method 1 (Using decorator)\n@pipeline.register(retries=3)\ndef get_all_users(data: Dict[str, str]) -&gt; Result[List[str], str]:\n    # Example task: Extract names from data\n    try:\n        names = [item[\"name\"] for item in data]\n        return Ok(names)\n    except KeyError as e:\n        return Err(f\"KeyError: {str(e)}\")\n\n\n# Define example tasks using pipeline\ndef filter_users_by_length(names) -&gt; Result[List[str], str]:\n    # Example task: Filter names based on criteria\n    filtered_names = [name for name in names if len(name) &gt; 3]\n    return Ok(filtered_names)\n\n\ndef calculate_statistics(filtered_names) -&gt; Result[Dict[str, int], str]:\n    # Example task: Calculate statistics\n    statistics = {\n        \"total_names\": len(filtered_names),\n        \"longest_name\": max(filtered_names, key=len) if filtered_names else None,\n    }\n    return Ok(statistics)\n\n\n# Example: Append tasks to the pipeline Alternative Method (Using append_function_as_task)\npipeline.append_function_to_registry(filter_users_by_length, retries=2)\n\n# Example: Append tasks to the pipeline Alternative Method (Using append_task)\npipeline.append_task_to_registry(Task(calculate_statistics, retries=2))\n\n\nif __name__ == \"__main__\":\n    # Sample data\n    sample_data = [\n        {\"name\": \"Alice\"},\n        {\"name\": \"Bob\"},\n        {\"name\": \"Charlie\"},\n        {\"name\": \"David\"},\n        {\"name\": \"Eve\"},\n    ]\n\n    # Print the execution plan\n    pipeline.print_execution_plan()\n\n    # Run the pipeline\n    result = pipeline.run(\n        sample_data, show_progress=True\n    )  # Set verbosity to True to display progress bar\n\n    # Check the final result\n    if result.is_ok():\n        final_statistics = result.unwrap()\n        logging.info(f\"Pipeline completed successfully. Statistics: {final_statistics}\")\n    else:\n        logging.error(f\"Pipeline failed. Error: {result.unwrap_err()}\")\n</code></pre>"},{"location":"examples/lambda_function/","title":"NeoPipe Example: Lambda Function","text":""},{"location":"examples/lambda_function/#difinition-of-lambda-function","title":"Difinition of Lambda Function","text":"<pre><code>import json\nimport logging\nfrom typing import List, Dict, Any\nfrom neopipe.pipeline import Pipeline\nfrom neopipe.result import Result, Ok, Err\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\npipeline = Pipeline()\n\n@pipeline.register(retries=3)\ndef process_fruit_data(fruit_data: List[Dict[str, Any]]) -&gt; Result[Dict[str, Any], str]:\n    try:\n        unique_fruits = list(set(item['fruit'] for item in fruit_data))\n        total_quantity = sum(item['quantity'] for item in fruit_data if item.get('quantity') is not None)\n        return Ok({\"unique_fruits\": unique_fruits, \"total_quantity\": total_quantity})\n    except (TypeError, KeyError) as e:\n        return Err(f\"Error processing fruit data: {str(e)}\")\n\n@pipeline.register(retries=3)\ndef calculate_average(data: Dict[str, Any]) -&gt; Result[Dict[str, Any], str]:\n    try:\n        total_quantity = data[\"total_quantity\"]\n        unique_fruits = data[\"unique_fruits\"]\n        average_quantity = total_quantity / len(unique_fruits) if unique_fruits else 0\n        return Ok({\n            \"unique_fruits\": unique_fruits,\n            \"total_quantity\": total_quantity,\n            \"average_quantity\": average_quantity\n        })\n    except (TypeError, KeyError, ZeroDivisionError) as e:\n        return Err(f\"Error calculating average quantity: {str(e)}\")\n\n\ndef handler(event, context):\n    # Run the pipeline\n    result = pipeline.run(event)\n\n    # Generate response based on the result\n    if result.is_ok():\n        final_result = result.unwrap()\n        return {\n            \"statusCode\": 200,\n            \"body\": json.dumps(final_result)\n        }\n    else:\n        error_message = result.unwrap_err()\n        return {\n            \"statusCode\": 400,\n            \"body\": json.dumps({\"error\": error_message})\n        }\n\n# Example event for local testing\nif __name__ == \"__main__\":\n    event = [\n        {\"fruit\": \"apple\", \"quantity\": 10},\n        {\"fruit\": \"banana\", \"quantity\": 20},\n        {\"fruit\": \"orange\", \"quantity\": None}\n    ]\n    context = {}\n    response = handler(event, context)\n    print(response)\n</code></pre>"},{"location":"examples/lambda_function/#output","title":"Output","text":"<pre><code>2024-06-26 00:23:28 - neopipe.task - INFO - Executing task process_fruit_data (UUID: 589cac3e-7b79-4fca-8fdf-fc129620e3c5)\n2024-06-26 00:23:28 - neopipe.task - INFO - Task process_fruit_data succeeded on attempt 1\n2024-06-26 00:23:28 - neopipe.task - INFO - Executing task calculate_average (UUID: 8725cf3d-5b01-47d1-a8dc-ebf891b5798d)\n2024-06-26 00:23:28 - neopipe.task - INFO - Task calculate_average succeeded on attempt 1\n{'statusCode': 200, 'body': '{\"unique_fruits\": [\"orange\", \"apple\", \"banana\"], \"total_quantity\": 30, \"average_quantity\": 10.0}'}\n</code></pre>"}]}